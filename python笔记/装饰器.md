# @property  装饰器
Python 提供了 property 装饰器，被装饰的方法，我们可以将其『当作』属性来用，看下面的例子：
~~~python
class Exam(object):
    def __init__(self, score):
        self._score = score

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, val):
        if val < 0:
            self._score = 0
        elif val > 100:
            self._score = 100
        else:
            self._score = val

>>> e = Exam(60)
>>> e.score
60
>>> e.score = 90
>>> e.score
90
>>> e.score = 200
>>> e.score
100
~~~
在上面，我们给方法 **score** 加上了 **@property**，于是我们可以把 score 当成一个属性来用，此时，又会创建一个新的装饰器 **score.setter**，它可以把被装饰的方法变成属性来赋值。
另外，我们也不一定要使用 score.setter 这个装饰器，这时 score 就变成一个只读属性了：
~~~python
class Exam(object):
    def __init__(self, score):
        self._score = score

    @property
    def score(self):
        return self._score

>>> e = Exam(60)
>>> e.score
60
>>> e.score = 200  # score 是只读属性，不能设置值
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-676-b0515304f6e0> in <module>()
----> 1 e.score = 200

AttributeError: can't set attribute
~~~
*  **@property** 把方法『变成』了属性。